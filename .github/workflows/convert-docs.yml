name: Convert Documentation

on:
  push:
    branches: [ main ]
    paths:
      - 'components/**/*.fodt'
  workflow_dispatch:  # Allow manual triggering

jobs:
  convert-and-sync:
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/${{ github.repository_owner }}/ecodocs-libreoffice:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    permissions:
      contents: write  # For source repo
      id-token: write  # For GitHub App token
      packages: read   # For container registry

    steps:
    - name: Checkout source
      uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Needed for git diff

    - name: Verify pre-built environment
      run: |
        echo "=== VERIFYING PRE-BUILT ENVIRONMENT ==="
        echo "üîç LibreOffice version:"
        soffice --version
        echo "üîç Python version:"
        python3 --version
        
        echo "üîç Checking DocExport extension..."
        ext_count=$(unopkg list --shared 2>/dev/null | grep "^Identifier:" | grep -i docexport | wc -l)
        echo "   Found $ext_count DocExport extension package(s)"
        
        if [ $ext_count -eq 0 ]; then
          echo "‚ùå ERROR: DocExport extension not found"
          exit 1
        elif [ $ext_count -gt 1 ]; then
          echo "‚ö†Ô∏è  WARNING: Multiple DocExport extensions detected ($ext_count instances)"
          echo "üßπ Attempting to clean up duplicate extensions..."
          
          # List all extensions for debugging
          echo "üìã Current extensions:"
          unopkg list --shared 2>/dev/null | head -20
          
          # Try to remove by identifier
          echo "üóëÔ∏è  Removing all DocExport instances..."
          unopkg remove --shared org.openoffice.legacy.DocExport.oxt 2>/dev/null || true
          sleep 2
          
          # Check if removal worked
          remaining=$(unopkg list --shared 2>/dev/null | grep "^Identifier:" | grep -i docexport | wc -l)
          echo "   Extension packages remaining after removal: $remaining"
          
          if [ $remaining -gt 0 ]; then
            echo "‚ö†Ô∏è  WARNING: Could not remove all duplicate extensions"
            echo "‚ö†Ô∏è  Proceeding anyway - conversion script will provide detailed diagnostics"
          else
            # Reinstall single instance
            echo "üì¶ Reinstalling DocExport extension..."
            if [ -f ".github/workflows/DocExport.oxt" ]; then
              unopkg add --shared .github/workflows/DocExport.oxt
              new_count=$(unopkg list --shared 2>/dev/null | grep "^Identifier:" | grep -i docexport | wc -l)
              echo "   Extension packages after reinstall: $new_count"
              
              if [ $new_count -eq 1 ]; then
                echo "‚úì Successfully cleaned up and reinstalled extension"
              else
                echo "‚ö†Ô∏è  WARNING: Unexpected extension count after reinstall: $new_count"
              fi
            fi
          fi
        else
          echo "‚úì DocExport extension found (single instance)"
        fi
        
        echo "‚úÖ Environment verification complete"

    - name: Load Conversion State
      id: load-state
      run: |
        echo "=== LOADING CONVERSION STATE ==="
        
        # Clone target repo to check for existing state
        eval "$(ssh-agent -s)"
        echo "${{ secrets.VITEPRESS_DEPLOY_TOKEN }}" | ssh-add -
        
        if git clone git@github.com:peerf-eco/docs-vitepress.git state-check; then
          echo "‚úÖ Target repository cloned for state check"
          
          if [ -f "state-check/.conversion-state.json" ]; then
            echo "üìÑ Found existing conversion state"
            cp state-check/.conversion-state.json ./current-state.json
            
            file_size=$(stat -c%s ./current-state.json 2>/dev/null || echo '0')
            echo "üìä State file size: $file_size bytes"
            
            # Validate state file is not empty or corrupted
            if [ "$file_size" -eq 0 ]; then
              echo "‚ö†Ô∏è  State file is empty, creating fresh state"
              echo '{}' > ./current-state.json
              LAST_COMMIT=""
            else
              # Extract last processed commit with error handling
              LAST_COMMIT=$(python3 .github/workflows/load_state.py 2>/dev/null || echo "")
              
              # Validate state file structure
              if ! python3 -c "import json; json.load(open('current-state.json'))" 2>/dev/null; then
                echo "‚ö†Ô∏è  State file is corrupted, creating fresh state"
                echo '{}' > ./current-state.json
                LAST_COMMIT=""
              else
                echo "‚úÖ State file validated successfully"
              fi
            fi
            
            echo "üîç Last processed commit: ${LAST_COMMIT:-'none'}"
            echo "LAST_PROCESSED_COMMIT=${LAST_COMMIT}" >> $GITHUB_ENV
            
            # Show current state summary
            python3 .github/workflows/show_state_summary.py 2>/dev/null || true
          else
            echo "‚ÑπÔ∏è  No existing state found, creating initial state"
            echo '{}' > ./current-state.json
            echo "LAST_PROCESSED_COMMIT=" >> $GITHUB_ENV
          fi
        else
          echo "‚ùå Failed to clone target repository for state check"
          exit 1
        fi
        
        rm -rf state-check
        echo "=== STATE LOADING COMPLETE ==="

    - name: Debug Git State
      id: debug-git
      run: |
        echo "=== GIT STATE DEBUG ==="
        
        # Fix git ownership issue
        git config --global --add safe.directory /__w/EcoDocs/EcoDocs
        
        echo "Current commit (HEAD): $(git rev-parse HEAD)"
        echo "Previous commit (HEAD~1): $(git rev-parse HEAD~1 2>/dev/null || echo 'N/A - single commit')"
        echo "Last processed commit: ${LAST_PROCESSED_COMMIT:-'none'}"
        echo "Fetch depth used: 2"
        echo "Git log (last 3 commits):"
        git log --oneline -3 || echo "Less than 3 commits available"
        echo "Files in components directory:"
        find components -name "*.fodt" -type f | head -10 || echo "No .fodt files found"
        echo "=== END GIT STATE DEBUG ===

    - name: Find changed files
      id: changed-files
      run: |
        echo "=== STATE-BASED CHANGE DETECTION ==="
        
        if [ -n "${LAST_PROCESSED_COMMIT}" ]; then
          echo "üîç Using state-based detection from commit: ${LAST_PROCESSED_COMMIT}"
          
          # Verify the commit exists
          if git rev-parse --verify "${LAST_PROCESSED_COMMIT}" >/dev/null 2>&1; then
            CHANGED_FILES=$(git diff --name-only ${LAST_PROCESSED_COMMIT}..HEAD -- 'components/**/*.fodt' 2>/dev/null || echo "")
            echo "‚úÖ Successfully compared against last processed commit"
          else
            echo "‚ö†Ô∏è  Last processed commit ${LAST_PROCESSED_COMMIT} not found, falling back to HEAD~1"
            CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD -- 'components/**/*.fodt' 2>/dev/null || echo "")
          fi
        else
          echo "üîç No previous state - initial run detected"
          echo "‚ÑπÔ∏è  Processing all .fodt files matching workflow trigger pattern"
          echo "üîç Path pattern: components/**/*.fodt"
          CHANGED_FILES=$(find components -name "*.fodt" -type f 2>/dev/null || echo "")
        fi
        
        echo "üìä Changed files found: $(echo "$CHANGED_FILES" | wc -w)"
        
        # Check for failed files from previous runs (with retry limit)
        FAILED_FILES=$(python3 .github/workflows/check_failed_files.py 2>/dev/null || echo "")
        
        failed_count=$(echo "$FAILED_FILES" | wc -w)
        if [ $failed_count -gt 0 ]; then
          echo "üîÑ Including $failed_count previously failed files for retry (within retry limit)"
        fi
        
        # Combine changed and failed files
        ALL_FILES="${CHANGED_FILES} ${FAILED_FILES}"
        ALL_FILES=$(echo $ALL_FILES | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/ $//')
        
        if [ -n "$ALL_FILES" ]; then
          echo "any_changed=true" >> $GITHUB_OUTPUT
          echo "all_changed_files=$ALL_FILES" >> $GITHUB_OUTPUT
          echo "‚úÖ Files to process: $ALL_FILES"
        else
          echo "any_changed=false" >> $GITHUB_OUTPUT
          echo "all_changed_files=" >> $GITHUB_OUTPUT
          echo "‚ÑπÔ∏è  No files to process"
        fi
        
        echo "=== END STATE-BASED CHANGE DETECTION ==="

    - name: Process Change Detection Results
      run: |
        echo "=== CHANGE DETECTION RESULTS ==="
        echo "Any files changed: ${{ steps.changed-files.outputs.any_changed }}"
        echo "All changed files: ${{ steps.changed-files.outputs.all_changed_files }}"
        
        # Fix boolean comparison syntax
        if [ "${{ steps.changed-files.outputs.any_changed }}" = "true" ]; then
          file_count=$(echo '${{ steps.changed-files.outputs.all_changed_files }}' | wc -w)
          echo "‚úÖ CHANGES DETECTED: $file_count file(s) to process"
          echo "Files to convert:"
          processable_files=0
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            echo "  - $file"
            if [ -f "$file" ]; then
              file_size=$(stat -c%s "$file" 2>/dev/null || echo '0')
              echo "    ‚úÖ File exists and is readable"
              echo "    üìä File size: $file_size bytes"
              
              if [ "$file_size" -eq 0 ]; then
                echo "    ‚ö†Ô∏è  WARNING: File is empty (0 bytes)"
              elif [ "$file_size" -lt 100 ]; then
                echo "    ‚ö†Ô∏è  WARNING: File is very small ($file_size bytes) - may be incomplete"
              fi
              processable_files=$((processable_files + 1))
            else
              echo "    ‚ùå WARNING: File not found or not readable (likely deleted)"
            fi
          done
          
          echo "üìä Summary: $processable_files processable files out of $file_count total changes"
        else
          echo "‚ÑπÔ∏è  NO CHANGES DETECTED"
          echo "Reason: No .fodt files in components/** have been modified since the last commit"
          echo "This is normal behavior - the workflow will skip conversion steps"
          
          # Additional debugging for no-changes scenario
          echo "üîç Additional debugging information:"
          echo "  - Current workflow path filter: components/**/*.fodt"
          echo "  - Comparison method: State-based or HEAD~1 fallback"
          echo "  - Repository has $(git rev-list --count HEAD 2>/dev/null || echo 'unknown') total commits"
        fi
        echo "=== END CHANGE DETECTION RESULTS ==="

    - name: No Changes Detected
      if: steps.changed-files.outputs.any_changed != 'true'
      run: |
        echo "=== NO CONVERSION NEEDED ==="
        echo "‚ÑπÔ∏è  WORKFLOW RESULT: No changes detected"
        echo ""
        echo "This means:"
        echo "  ‚Ä¢ No .fodt files in components/** have been modified since the last commit"
        echo "  ‚Ä¢ The workflow is working correctly by skipping unnecessary conversions"
        echo "  ‚Ä¢ No files will be converted or pushed to the target repository"
        echo ""
        echo "If you expected changes to be detected:"
        echo "  1. Verify your .fodt files are in the components/ directory"
        echo "  2. Check that files were actually modified in the last commit"
        echo "  3. Ensure the workflow path filter matches your file locations"
        echo ""
        echo "Current workflow path filter: components/**/*.fodt"
        echo "=== WORKFLOW COMPLETE (NO ACTION REQUIRED) ==="

    - name: Convert to Markdown
      id: convert
      if: steps.changed-files.outputs.any_changed == 'true'
      timeout-minutes: 15
      run: |
        echo "=== CONVERSION START ==="
        file_count=$(echo '${{ steps.changed-files.outputs.all_changed_files }}' | wc -w)
        echo "üîÑ Starting conversion of $file_count file(s)"
        echo "Files to convert: ${{ steps.changed-files.outputs.all_changed_files }}"
        
        # Export GitHub environment variables for the script
        echo "GITHUB_SERVER_URL=${{ github.server_url }}" >> $GITHUB_ENV
        echo "GITHUB_REPOSITORY=${{ github.repository }}" >> $GITHUB_ENV
        echo "GITHUB_SHA=${{ github.sha }}" >> $GITHUB_ENV
        
        # Create converted_docs directory and list contents before conversion
        mkdir -p converted_docs
        echo "Contents before conversion:"
        ls -la converted_docs/ || echo "Directory is empty"
        
        # Call the extension-based conversion script with ALL files as arguments
        echo "üöÄ Executing batch conversion script..."
        
        # Filter out non-existent files
        EXISTING_FILES=""
        for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
          if [ -f "$file" ]; then
            EXISTING_FILES="$EXISTING_FILES $file"
          else
            echo "‚ö†Ô∏è  Skipping non-existent file: $file"
          fi
        done
        
        if [ -n "$EXISTING_FILES" ]; then
          echo "üîÑ Processing files: $EXISTING_FILES"
          bash .github/workflows/convert_docs_extension.sh $EXISTING_FILES
        else
          echo "‚ùå No valid files to process"
          exit 1
        fi
        
    - name: Verify Conversion Results
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        echo "=== CONVERSION VERIFICATION ==="
        
        if [ -d "converted_docs" ]; then
          echo "üìÅ Converted docs directory contents:"
          ls -la converted_docs/
          
          md_count=$(find converted_docs -name "*.md" | wc -l)
          echo "üìÑ Total .md files created: $md_count"
          
          if [ $md_count -gt 0 ]; then
            echo "‚úÖ Conversion successful - found $md_count markdown file(s)"
            echo "üìã Generated files:"
            find converted_docs -name "*.md" -exec basename {} \; | sort
            
            echo "üìä File sizes:"
            find converted_docs -name "*.md" -exec ls -lh {} \; | awk '{print "  " $9 ": " $5}'
          else
            echo "‚ö†Ô∏è  WARNING: No markdown files were created"
            echo "üîç Checking for other file types:"
            find converted_docs -type f | head -10
          fi
        else
          echo "‚ùå ERROR: converted_docs directory not found"
          echo "üîç Current directory contents:"
          ls -la
          exit 1
        fi
        echo "=== END CONVERSION VERIFICATION ==="

    - name: Update Conversion State
      id: update-state
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        echo "=== UPDATING CONVERSION STATE ==="
        
        # Create new state with corrected logic
        python3 .github/workflows/update_state.py
        
        echo "üìä New state file created:"
        ls -la new-state.json
        echo "üìÑ State summary:"
        python3 -c "import json; s=json.load(open('new-state.json')); print(f'Successful: {len(s.get(\"successfulFiles\",{}))} Failed: {len(s.get(\"failedFiles\",{}))} Commit: {s.get(\"lastProcessedCommit\",\"none\")}')"
        echo "=== STATE UPDATE COMPLETE ==="

    - name: Clone, copy files, and push to docs repo
      id: deploy
      if: steps.changed-files.outputs.any_changed == 'true'
      env:
        TARGET_REPO_SSH_KEY: ${{ secrets.VITEPRESS_DEPLOY_TOKEN }}
      shell: bash
      run: |
        set -euo pipefail
        echo "=== DEPLOYMENT TO TARGET REPOSITORY START ==="
        echo "üéØ Target repository: peerf-eco/docs-vitepress"
        echo "üìÇ Source directory: converted_docs/"
        echo "üìÇ Target directory: docs/components/"
        
        # Setup SSH
        echo "üîê Setting up SSH authentication..."
        if mkdir -p ~/.ssh; then
          echo "‚úÖ SSH directory created"
        else
          echo "‚ùå Failed to create SSH directory"
          exit 1
        fi
        
        echo "üîë Adding GitHub to known hosts..."
        if ssh-keyscan -t ed25519,rsa github.com >> ~/.ssh/known_hosts; then
          echo "‚úÖ GitHub added to known hosts"
        else
          echo "‚ùå Failed to add GitHub to known hosts"
          exit 1
        fi
        
        echo "üîë Starting SSH agent..."
        if eval "$(ssh-agent -s)"; then
          echo "‚úÖ SSH agent started"
        else
          echo "‚ùå Failed to start SSH agent"
          exit 1
        fi
        
        echo "üîë Adding SSH key..."
        if echo "$TARGET_REPO_SSH_KEY" | ssh-add -; then
          echo "‚úÖ SSH key added successfully"
        else
          echo "‚ùå Failed to add SSH key"
          echo "üîç SSH key length: ${#TARGET_REPO_SSH_KEY} characters"
          exit 1
        fi
        
        # Clone and copy files
        echo "üíæ Cloning target repository..."
        if git clone git@github.com:peerf-eco/docs-vitepress.git docs-vitepress; then
          echo "‚úÖ Repository cloned successfully"
          echo "üìÅ Cloned repository contents:"
          ls -la docs-vitepress/ | head -10
        else
          echo "‚ùå Failed to clone repository"
          echo "üîç Testing SSH connection to GitHub:"
          ssh -T git@github.com || echo "SSH connection test failed"
          exit 1
        fi
        
        # Verify source directory exists
        if [ ! -d "converted_docs" ]; then
          echo "‚ùå ERROR: converted_docs directory not found"
          exit 1
        fi
        
        echo "üìã Files available for deployment:"
        ls -la converted_docs/
        
        # Check for image folders
        echo "üñºÔ∏è Checking for image folders..."
        img_folders_found=$(find converted_docs -maxdepth 1 -type d -name "img_*" | wc -l)
        if [ $img_folders_found -gt 0 ]; then
          echo "  ‚úÖ Found $img_folders_found image folder(s):"
          find converted_docs -maxdepth 1 -type d -name "img_*" -exec basename {} \;
        else
          echo "  ‚ÑπÔ∏è No image folders found (img_* pattern)"
        fi
        
        targetDir="docs-vitepress/docs/components"
        mkdir -p "$targetDir"
        echo "üìÅ Created target directory: $targetDir"
        
        filesCopied=0
        filesSkipped=0
        imagesFoldersCopied=0
        echo "üîÑ Starting file copy process..."
        
        # Copy markdown files
        while IFS= read -r file; do
          src="converted_docs/${file}"
          if [ -f "$src" ]; then
            if cp "$src" "$targetDir/"; then
              echo "  ‚úÖ Copied: ${file} ($(stat -c%s "$src" 2>/dev/null || echo '?') bytes)"
              filesCopied=$((filesCopied+1))
              
              # Check for corresponding image folder
              base_name="${file%.md}"
              img_folder="converted_docs/img_${base_name}"
              if [ -d "$img_folder" ]; then
                echo "  üìÅ Found image folder: img_${base_name}"
                if cp -r "$img_folder" "$targetDir/"; then
                  echo "  ‚úÖ Copied image folder: img_${base_name}"
                  imagesFoldersCopied=$((imagesFoldersCopied+1))
                else
                  echo "  ‚ùå Failed to copy image folder: img_${base_name}"
                fi
              fi
            else
              echo "  ‚ùå Failed to copy: ${file}"
              filesSkipped=$((filesSkipped+1))
            fi
          else
            echo "  ‚ö†Ô∏è  Skipped (not a file): ${file}"
            filesSkipped=$((filesSkipped+1))
          fi
        done < <(ls converted_docs 2>/dev/null || echo "")
        
        echo "üìä Copy summary: $filesCopied files copied, $imagesFoldersCopied image folders copied, $filesSkipped files skipped"
        
        if [ $filesCopied -eq 0 ]; then
          echo "‚ö†Ô∏è  WARNING: No files were copied to target repository"
        fi
        
        if [ $imagesFoldersCopied -gt 0 ]; then
          echo "‚úÖ Successfully copied $imagesFoldersCopied image folder(s) with markdown files"
        fi
        
        # Push changes
        pushd docs-vitepress >/dev/null
        git config user.name "Docs CI Bot"
        git config user.email "docs-bot@ecoos.dev"
        git add docs/components/
        # Copy state file to target repository with validation
        if [ -f "../new-state.json" ]; then
          echo "üìÑ Copying conversion state to target repository"
          
          # Validate state file before copying
          if python3 -c "import json; json.load(open('../new-state.json'))" 2>/dev/null; then
            cp ../new-state.json .conversion-state.json
            echo "‚úÖ State file copied and validated"
            echo "üìä New state file size: $(stat -c%s .conversion-state.json) bytes"
            git add .conversion-state.json
          else
            echo "‚ùå State file validation failed, not copying corrupted state"
            # Keep existing state file if new one is corrupted
            if [ -f ".conversion-state.json" ]; then
              echo "‚ÑπÔ∏è  Keeping existing state file"
            fi
          fi
        else
          echo "‚ö†Ô∏è  No new state file found, state will not be updated"
          # This is an edge case that shouldn't happen if update-state step succeeded
        fi
        
        # Check for changes and commit
        echo "üîç Checking for changes in target repository..."
        git status --porcelain docs/components/ .conversion-state.json
        
        if ! git diff --staged --quiet; then
          sha="${GITHUB_SHA:-unknown-sha}"
          echo "‚úÖ Changes detected, committing and pushing..."
          echo "üìù Commit message: Auto-update docs from ${sha}"
          git commit -m "Auto-update docs from ${sha}"
          
          if git push origin HEAD:main; then
            echo "üöÄ Successfully pushed to docs-vitepress repository"
          else
            echo "‚ùå Failed to push to target repository"
            exit 1
          fi
        else
          echo "‚ÑπÔ∏è  No changes to commit - files may already be up to date"
        fi
        popd >/dev/null
        echo "=== DEPLOYMENT COMPLETE ==="
  
    - name: Generate and update components manifest
      id: manifest
      if: steps.changed-files.outputs.any_changed == 'true'
      env:
        TARGET_REPO_SSH_KEY: ${{ secrets.VITEPRESS_DEPLOY_TOKEN }}
      shell: bash
      run: |
        set -eo pipefail
        echo "=== MANIFEST GENERATION START ==="
        echo "üìÑ Generating components manifest for updated documentation"
        
        pushd docs-vitepress >/dev/null
        
        # Check if package.json exists and is valid
        if [ ! -f "package.json" ]; then
          echo "‚ö†Ô∏è  No package.json found in target repository, skipping manifest generation"
          echo "This is normal if the target repository doesn't use npm-based manifest generation"
          popd >/dev/null
          exit 0
        fi
        echo "‚úÖ Found package.json in target repository"
        
        # Validate JSON syntax
        if ! python3 -m json.tool package.json >/dev/null 2>&1; then
          echo "‚ùå Invalid package.json syntax, skipping manifest generation"
          echo "üîç First few lines of package.json:"
          head -5 package.json || echo "Cannot read package.json"
          popd >/dev/null
          exit 0
        fi
        echo "‚úÖ package.json syntax is valid"
        
        # Check if the required script exists
        if ! grep -q '"docs:generate-components"' package.json; then
          echo "‚ö†Ô∏è  docs:generate-components script not found in package.json"
          echo "Available scripts:"
          grep -A 10 '"scripts"' package.json | head -15 || echo "No scripts section found"
          echo "Skipping manifest generation"
          popd >/dev/null
          exit 0
        fi
        echo "‚úÖ Found docs:generate-components script"
        
        echo "üì¶ Installing dependencies..."
        if npm ci 2>/dev/null; then
          echo "‚úÖ Dependencies installed successfully using npm ci"
        elif npm install 2>/dev/null; then
          echo "‚úÖ Dependencies installed successfully using npm install"
        else
          echo "‚ùå Failed to install dependencies"
          echo "üîç npm version: $(npm --version 2>/dev/null || echo 'not available')"
          echo "üîç node version: $(node --version 2>/dev/null || echo 'not available')"
          echo "Skipping manifest generation"
          popd >/dev/null
          exit 0
        fi
        
        echo "üîÑ Generating components manifest..."
        if npm run docs:generate-components; then
          echo "‚úÖ Manifest generation completed successfully"
        else
          echo "‚ùå Failed to generate manifest"
          echo "üîç Checking for existing manifest file:"
          ls -la .vitepress/components.json 2>/dev/null || echo "No existing manifest found"
          echo "Continuing without manifest update"
          popd >/dev/null
          exit 0
        fi
        
        # Setup SSH and push if manifest was generated
        if [ -f ".vitepress/components.json" ]; then
          echo "‚úÖ Manifest file generated: .vitepress/components.json"
          echo "üìä Manifest file size: $(stat -c%s .vitepress/components.json 2>/dev/null || echo 'unknown') bytes"
          
          mkdir -p ~/.ssh
          ssh-keyscan -t ed25519,rsa github.com >> ~/.ssh/known_hosts
          eval "$(ssh-agent -s)"
          echo "$TARGET_REPO_SSH_KEY" | ssh-add -
          
          git add .vitepress/components.json
          if ! git diff --staged --quiet; then
            echo "üìù Committing manifest changes..."
            git config user.name "Docs CI Bot"
            git config user.email "docs-bot@ecoos.dev"
            git commit -m "Auto-update components manifest from ${GITHUB_SHA:-unknown-sha}"
            
            if git push origin HEAD:main; then
              echo "üöÄ Successfully pushed manifest update"
            else
              echo "‚ùå Failed to push manifest update"
            fi
          else
            echo "‚ÑπÔ∏è  No manifest changes to commit (manifest unchanged)"
          fi
        else
          echo "‚ö†Ô∏è  No manifest file found after generation"
        fi
        
        popd >/dev/null
        echo "=== MANIFEST GENERATION COMPLETE ===

    - name: Workflow Summary
      if: always()
      run: |
        echo "=== WORKFLOW EXECUTION SUMMARY ==="
        echo "üìÖ Execution date: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üåê Repository: ${{ github.repository }}"
        echo "üîó Commit: ${{ github.sha }}"
        echo "üèÉ Triggered by: ${{ github.event_name }}"
        echo "üï∞Ô∏è Workflow run ID: ${{ github.run_id }}"
        
        # Check step outcomes
        echo "üîç Step execution status:"
        echo "  - Git state debug: ${{ steps.debug-git.outcome || 'not executed' }}"
        echo "  - Change detection: ${{ steps.changed-files.outcome || 'not executed' }}"
        echo "  - Conversion: ${{ steps.convert.outcome || 'skipped' }}"
        echo "  - Deployment: ${{ steps.deploy.outcome || 'skipped' }}"
        echo "  - Manifest generation: ${{ steps.manifest.outcome || 'skipped' }}"
        
        # Overall workflow status
        if [ "${{ job.status }}" = "success" ]; then
          echo "‚úÖ WORKFLOW STATUS: SUCCESS"
        elif [ "${{ job.status }}" = "failure" ]; then
          echo "‚ùå WORKFLOW STATUS: FAILED"
          echo "üîç Check the failed steps above for error details"
        elif [ "${{ job.status }}" = "cancelled" ]; then
          echo "‚ö†Ô∏è  WORKFLOW STATUS: CANCELLED"
        else
          echo "üîÑ WORKFLOW STATUS: ${{ job.status }}"
        fi
        
        # File processing summary
        if [ "${{ steps.changed-files.outputs.any_changed }}" = "true" ]; then
          echo "üü¢ PROCESSING RESULT: CHANGES DETECTED AND PROCESSED"
          echo "üìÑ Files in scope: $(echo '${{ steps.changed-files.outputs.all_changed_files }}' | wc -w)"
          echo "üéØ Target repository: peerf-eco/docs-vitepress"
          
          # State tracking summary
          if [ -f "new-state.json" ]; then
            echo "üìÑ State tracking summary:"
            python3 -c "import json; s=json.load(open('new-state.json')); print(f'  - Files: {len(s.get(\"successfulFiles\",{}))} success, {len(s.get(\"failedFiles\",{}))} failed')" 2>/dev/null || echo "  - State unavailable"
          fi
          
          # Check if conversion actually succeeded
          if [ "${{ steps.convert.outcome }}" = "success" ]; then
            echo "‚úÖ Conversion completed successfully"
          elif [ "${{ steps.convert.outcome }}" = "failure" ]; then
            echo "‚ùå Conversion failed - check conversion logs"
          fi
          
          # Check if deployment succeeded
          if [ "${{ steps.deploy.outcome }}" = "success" ]; then
            echo "‚úÖ Deployment completed successfully"
          elif [ "${{ steps.deploy.outcome }}" = "failure" ]; then
            echo "‚ùå Deployment failed - check deployment logs"
          fi
          
          # Check if state update succeeded
          if [ "${{ steps.update-state.outcome }}" = "success" ]; then
            echo "‚úÖ State tracking updated successfully"
          elif [ "${{ steps.update-state.outcome }}" = "failure" ]; then
            echo "‚ùå State tracking update failed"
          fi
        else
          echo "üü° PROCESSING RESULT: NO CHANGES DETECTED"
          echo "üìÑ Files processed: 0"
          echo "üéØ Target repository: No updates needed"
          
          # Show current state even when no changes
          if [ -f "current-state.json" ]; then
            echo "üìÑ Current state summary:"
            python3 -c "import json; s=json.load(open('current-state.json')); print(f'  - Files: {len(s.get(\"successfulFiles\",{}))} success, {len(s.get(\"failedFiles\",{}))} failed')" 2>/dev/null || echo "  - No state available"
          fi
        fi
        
        # Troubleshooting guidance
        if [ "${{ job.status }}" != "success" ]; then
          echo ""
          echo "üîß TROUBLESHOOTING GUIDANCE:"
          echo "  1. Check the step-by-step logs above for specific error messages"
          echo "  2. Look for ‚ùå (error) and ‚ö†Ô∏è (warning) indicators in the logs"
          echo "  3. Verify that .fodt files exist in the components/ directory"
          echo "  4. Ensure SSH keys and repository permissions are correct"
          echo "  5. Check if LibreOffice and DocExport extension installed properly"
        fi
        
        echo "üîç For detailed logs, check the individual step outputs above"
        echo "=== END WORKFLOW SUMMARY ==="
